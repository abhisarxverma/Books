# **ðŸ¤º Chapter 2 - An Array of Seuquences**

## **Overview of Built-In-Sequences**

1. ***Container*** - Sequences that hold the items of different types, including the nested containers. They hold the ***references*** to the object it contains. E.g - tuple, list
2. ***flat*** - Sequences that hold items of single type. They hold the value of it's contents in it's own memory space, instead of distinct python objects. E.g - String, bytes, array.array

Another way of grouping :
1. ***Mutable*** - The contents can be changed after the initialization. E.g - List, array
2. ***Immutable*** - The contents cannot be changed after the initializaiton. E.g - String, Tuple, bytes

*Subclass hierarchy*
- Sequence (Immutable sequence) inherits from the *collection* and *reversed* super classes.
- Mutable Sequence inherits from the *Sequence* super class.

## **List Comprehension and Generator Expressions**

> *Python programmers use cool words for - List Comprehension - **listcomps** / Generator Expressions - **genexps***

Genexps are more faster than the listcomps at least in some cases.

## **Tuples are not just Immutable lists**

### **Tuples as records**

Tuples are Immutables and also hold the sequence in which the elements are put. Hence, it is the most simplest datatype to hold the records in python.

### **Tuples as Immutable lists**

A Tuple takes less memory as compared to the list of the same length.

*Tricky thing* - Tuples themselves are **immutable** which means you cannot change it after defining, but if you have reference to a **mutable object** in the tuple and then you change that **mutable object** like list then the tuple changes and no longer remains the same.

```python
>>> a = (10, 'alpha', [1, 2])
>>> b = (10, 'alpha', [1, 2])
>>> a == b
True
>>> b[-1].append(99)
>>> a == b
False
>>> b
(10, 'alpha', [1, 2, 99])
```

Here after appending the 99 to the list at third index in b tuple the tuple is not the same as the a.

Also you cannot **hash** a tuple with reference to any **mutable object** in it.

```python
>>> def fixed(o):
...     try:
...         hash(o)
...     except TypeError:
...         return False
...     return True
...
>>> tf = (10, 'alpha', (1, 2))
>>> tm = (10, 'alpha', [1, 2])
>>> fixed(tf)
True
>>> fixed(tm)
False
```

As you **cannot hash** a tuple with **mutable object** in it, you cannot use that tuple as the key in the **dictionary** or in the **set** cause it can ***change***.

### **Performance advantages of tuple over lists by *Raymond Hettinger***

- To  evaluate  a  tuple  literal,  the  Python  compiler  generates  **bytecode**  for  a  tuple constant  in  **one  operation**;  but  for  a  list  literal,  the  generated bytecode  pushes each element as a **separate constant** to the data stack, and then builds the list.

- Given  a  tuple  t,  tuple(t)  simply  returns  a  ***reference  to  the  same  t***.  Thereâ€™s  no need  to  copy.  In  contrast,  given  a  list  l,  the  list(l)  constructor  must  ***create  a new copy of l***.

- Tuples are allocated the ***exact memory space*** of their length, but the lists are given ***some room to spare***, to amortize the cost for the future appends.

- The  references  to  the  items  in  a  tuple  are  stored  in  an  array  in  the ***tuple  struct***, while  a  list  holds  a  ***pointer  to  an  array  of  references***  *stored  elsewhere*.  The  indirection is necessary because when a list grows beyond the space currently allocated,  Python  needs  to  reallocate  the  array  of  references  to  make  room.  The  extra indirection makes CPU caches less effective.

## **Pattern Matching With Sequences**

```python
def handle_command(self, message):
        match message:  
            case ['BEEPER', frequency, times]:  
                self.beep(times, frequency)
            case ['NECK', angle]:  
                self.rotate_neck(angle)
            case ['LED', ident, intensity]:  
                self.leds[ident].set_brightness(ident, intensity)
            case ['LED', ident, red, green, blue]:  
                self.leds[ident].set_color(ident, red, green, blue)
            case _:  
                raise InvalidCommand(message)
```

The **match/case** have one key improvement over the **switch/case** of the C language, which is the **destructuring**.

The **handle command** function takes a *message* sequence and perform a match case.

In general, a sequence pattern matches the subject if:

1. The subject is a sequence and;
2. The subject and the pattern have the same number of items and;
3. Each corresponding item matches, including nested items.

The unknown variable that you are seeing in the case's sequence, will try to unpack the items in the message into them.

The last case block have the "_", which is the default case , if the messsage does not match to any of the cases above then, it gets to the default "_" case.

## **ðŸ”ª Slicing**

### **Slice objects**

The  notation  a:b:c  is  only  valid  within  `[]`  when  used  as  the  indexing  or  subscript
operator, and it produces a slice object: `slice(a, b, c)`.

Python calles `sq.__getitem__(slice(a, b, c))`

Slice objects, let's you assign name to the slices, just like spreadsheets allow the naming of the cell ranges.

```python
invoice = """
... 0.....6.................................40........52...55........
... 1909  Pimoroni PiBrella                     $17.50    3    $52.50
... 1489  6mm Tactile Switch x20                 $4.95    2     $9.90
... 1510  Panavise Jr. - PV-201                 $28.00    1    $28.00
... 1601  PiTFT Mini Kit 320x240                $34.95    1    $34.95
... """

>>> SKU = slice(0, 6)
>>> DESCRIPTION = slice(6, 40)
>>> UNIT_PRICE = slice(40, 52)
>>> QUANTITY =  slice(52, 55)
>>> ITEM_TOTAL = slice(55, None)
>>> line_items = invoice.split('\n')[2:]
>>> for item in line_items:
...     print(item[UNIT_PRICE], item[DESCRIPTION])
"""
    $17.50   Pimoroni PiBrella
     $4.95   6mm Tactile Switch x20
    $28.00   Panavise Jr. - PV-201
    $34.95   PiTFT Mini Kit 320x240
"""
```

## **Multidimensional Slicing And Ellipsis**

The  []  operator  can  also  take  multiple  indexes  or  slices  separated  by  commas.  The
`__getitem__`  and  `__setitem__`  special  methods  that  handle  the  `[]`  operator  simply
receive the indices in `a[i, j]` as a tuple. In other words, to evaluate `a[i, j]`, Python
calls `a.__getitem__((i, j))`

Ellipsis is formed from the built-in python ellipsis class.

Used in the numpy's multidimensional array, as shorthand to select all the rows and columns.

Slices also change the sequence in-place.