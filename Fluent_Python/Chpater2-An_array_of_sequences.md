# **ðŸ¤º Chapter 2 - An Array of Seuquences**

## **Overview of Built-In-Sequences**

1. ***Container*** - Sequences that hold the items of different types, including the nested containers. They hold the ***references*** to the object it contains. E.g - tuple, list
2. ***flat*** - Sequences that hold items of single type. They hold the value of it's contents in it's own memory space, instead of distinct python objects. E.g - String, bytes, array.array

Another way of grouping :
1. ***Mutable*** - The contents can be changed after the initialization. E.g - List, array
2. ***Immutable*** - The contents cannot be changed after the initializaiton. E.g - String, Tuple, bytes

*Subclass hierarchy*
- Sequence (Immutable sequence) inherits from the *collection* and *reversed* super classes.
- Mutable Sequence inherits from the *Sequence* super class.

## **List Comprehension and Generator Expressions**

> *Python programmers use cool words for - List Comprehension - **listcomps** / Generator Expressions - **genexps***

Genexps are more faster than the listcomps at least in some cases.

## **Tuples are not just Immutable lists**

### **Tuples as records**

Tuples are Immutables and also hold the sequence in which the elements are put. Hence, it is the most simplest datatype to hold the records in python.

### **Tuples as Immutable lists**

A Tuple takes less memory as compared to the list of the same length.

*Tricky thing* - Tuples themselves are **immutable** which means you cannot change it after defining, but if you have reference to a **mutable object** in the tuple and then you change that **mutable object** like list then the tuple changes and no longer remains the same.

```python
>>> a = (10, 'alpha', [1, 2])
>>> b = (10, 'alpha', [1, 2])
>>> a == b
True
>>> b[-1].append(99)
>>> a == b
False
>>> b
(10, 'alpha', [1, 2, 99])
```

Here after appending the 99 to the list at third index in b tuple the tuple is not the same as the a.

Also you cannot **hash** a tuple with reference to any **mutable object** in it.

```python
>>> def fixed(o):
...     try:
...         hash(o)
...     except TypeError:
...         return False
...     return True
...
>>> tf = (10, 'alpha', (1, 2))
>>> tm = (10, 'alpha', [1, 2])
>>> fixed(tf)
True
>>> fixed(tm)
False
```

As you **cannot hash** a tuple with **mutable object** in it, you cannot use that tuple as the key in the **dictionary** or in the **set** cause it can ***change***.

### **Performance advantages of tuple over lists by *Raymond Hettinger***

- To  evaluate  a  tuple  literal,  the  Python  compiler  generates  **bytecode**  for  a  tuple constant  in  **one  operation**;  but  for  a  list  literal,  the  generated bytecode  pushes each element as a **separate constant** to the data stack, and then builds the list.

- Given  a  tuple  t,  tuple(t)  simply  returns  a  ***reference  to  the  same  t***.  Thereâ€™s  no need  to  copy.  In  contrast,  given  a  list  l,  the  list(l)  constructor  must  ***create  a new copy of l***.

- Tuples are allocated the ***exact memory space*** of their length, but the lists are given ***some room to spare***, to amortize the cost for the future appends.

- The  references  to  the  items  in  a  tuple  are  stored  in  an  array  in  the ***tuple  struct***, while  a  list  holds  a  ***pointer  to  an  array  of  references***  *stored  elsewhere*.  The  indirection is necessary because when a list grows beyond the space currently allocated,  Python  needs  to  reallocate  the  array  of  references  to  make  room.  The  extra indirection makes CPU caches less effective.